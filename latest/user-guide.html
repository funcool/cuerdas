<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">funcool/cuerdas</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cuerdas</span></div></div></li><li class="depth-2 branch"><a href="cuerdas.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="cuerdas.regexp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>regexp</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" id="user-guide"></a>User Guide</h1>
<h2><a href="#introduction" id="introduction"></a>Introduction</h2>
<p>The missing clojure(script) string manipulation library.</p>
<pre><code>La guitarra,
hace llorar a los sueños.
El sollozo de las almas
perdidas,
se escapa por su boca
redonda.
Y como la tarántula
teje una gran estrella
para cazar suspiros,
que flotan en su negro
aljibe de madera.
</code></pre>
<h2><a href="#install" id="install"></a>Install</h2>
<p>Add the following dependency to your project.clj file:</p>
<pre><code class="language-clojure">funcool/cuerdas {:mvn/version "2023.10.15-405"}
</code></pre>
<h2><a href="#quick-start" id="quick-start"></a>Quick start</h2>
<pre><code class="language-clojure">(ns my.namespace
  (:require [cuerdas.core :as str]))
</code></pre>
<pre><code class="language-clojure">(str/strip-tags "&lt;p&gt;just &lt;b&gt;some&lt;/b&gt; text&lt;/p&gt;")
;; =&gt; "just some text"

(str/strip-tags "&lt;p&gt;just &lt;b&gt;some&lt;/b&gt; text&lt;/p&gt;" ["p"])
;; =&gt; "just &lt;b&gt;some&lt;/b&gt; text"
</code></pre>
<p><strong>NOTE</strong>: this library only intends to work with strings and always being null-safe. So practically all functions that expectes a <code>string</code> as argument and receives a <code>nil</code> will return <code>nil</code>.</p>
<h2><a href="#self-host-clojurescript" id="self-host-clojurescript"></a>Self-host ClojureScript</h2>
<pre><code>lumo -c $(clojure -Srepro -Sdeps '{:deps {funcool/cuerdas {:mvn/version "X.Y.Z"}}}' -Spath)
</code></pre>
<pre><code class="language-clojure">cljs.user=&gt; (require '[cuerdas.core :as str])
;; =&gt; nil
cljs.user=&gt; (str/collapse-whitespace " foo bar    ")
;; =&gt; "foo bar"
</code></pre>
<h2><a href="#reference" id="reference"></a>Reference</h2>
<p><strong>NOTE</strong>: this section expalins only a limited set of functions, for complete overview look at the namespace functions reference.</p>
<h3><a href="#-" id="-"></a>&lt;&lt;-</h3>
<p>Unindent lines. Either strip preceding whitespace automatically or with a user supplied regex.</p>
<pre><code class="language-clojure">(str/&lt;&lt;- "first line

            second line (indented)

          another line")
</code></pre>
<p>yields the string</p>
<pre><code class="language-clojure">first line

  second line (indented)

another line
</code></pre>
<h3><a href="#concat" id="concat"></a>concat</h3>
<p>This is a macro variant of <code>clojure.core/str</code> function that performs string concatenation. It is considerably faster on CLJS and slightly faster on JVM.</p>
<p>On CLJS, it uses the <code>+</code> native operator to perform the concatenation that is more optimized than the <code>[].join(...)</code> for the vast majority of cases. On the JVM it only simplifies contiguos strings that are know to be string instances at compile time.</p>
<pre><code class="language-clojure">(str/concat "foo" 1 "bar")
;; =&gt; "foo1bar"
</code></pre>
<p>There some benchmark result with huge number of items to concatenate:</p>
<pre><code class="language-clojure">;; =&gt; benchmarking: cljs.core/str
;; --&gt; WARM:  100000
;; --&gt; BENCH: 500000
;; --&gt; TOTAL: 197.82ms
;; --&gt; MEAN:  395.64ns
;; =&gt; benchmarking: cuerdas.core/concat
;; --&gt; WARM:  100000
;; --&gt; BENCH: 500000
;; --&gt; TOTAL: 20.31ms
;; --&gt; MEAN:  40.63ns
</code></pre>
<h3><a href="#istr" id="istr"></a>istr</h3>
<p>String interpolation macro. Enables easy string formating allowing symbol substitutions and simple expression evaluation. Very similar to the ES6 template strings. At the moment not compatible with self-host ClojureScript.</p>
<pre><code class="language-clojure">(def value 30)

(str/istr "value = ~{value}")
;; =&gt; "value = 30"

(str/istr "value = ~(inc value)")
;; =&gt; "value = 31"
</code></pre>
<p>The <code>istr</code> macro is variadic and allows arbitrary number of arguments that will be concatenated on the final return value:</p>
<pre><code class="language-clojure">(str/istr "the value "
          "is ~{value}")
;; =&gt; "the value is 30"
</code></pre>
<p>This macro ends using the fast string concatenation thanks to <code>concat</code> macro.</p>
<h3><a href="#ffmt" id="ffmt"></a>ffmt</h3>
<p>Another string formating, simplier alternative to the <code>istr</code> macro.</p>
<p>It works with two basic forms: sequencial and indexed. Let seen an example:</p>
<pre><code class="language-clojure">(str/ffmt "url(%, %)" my-url my-label) ; sequential access
(str/ffmt "url(%1, %2)" my-url my-label) ; indexed access
</code></pre>
<p>If you need the <code>%</code> character, just duplicate it:</p>
<pre><code class="language-clojure">(str/ffmt "%1%%" 1)
;; =&gt; "1%"

(str/ffmt "%%%" 1)
;; =&gt; "%1"
</code></pre>
<p>This macro ends using the fast string concatenation thanks to <code>concat</code> macro.</p>
<h3><a href="#alnum" id="alnum"></a>alnum?</h3>
<p>Checks if a string contains only alphanumeric characters.</p>
<pre><code class="language-clojure">(str/alnum? nil)
;; =&gt; false

(str/alnum? "")
;; =&gt; false

(str/alnum? "Test123")
;; =&gt; true
</code></pre>
<h3><a href="#alpha" id="alpha"></a>alpha?</h3>
<p>Checks if a string contains only alpha characters.</p>
<pre><code class="language-clojure">(str/alpha? nil)
;; =&gt; false

(str/alpha? " ")
;; =&gt; false

(str/alpha? "Test")
;; =&gt; true
</code></pre>
<h3><a href="#blank" id="blank"></a>blank?</h3>
<p>Check if the string is empty or contains only whitespaces.</p>
<pre><code class="language-clojure">(str/blank? "foobar")
;; =&gt; false

(str/blank? "   ")
;; =&gt; true

(str/blank? "")
;; =&gt; true

(str/blank? nil)
;; =&gt; false
</code></pre>
<h3><a href="#camel" id="camel"></a>camel</h3>
<p>Convert a string or keyword to a camelCased string.</p>
<pre><code class="language-clojure">(str/camel "foo bar")
;; =&gt; "fooBar"

(str/camel :foo_barBaz)
;; =&gt; "fooBarBaz"

(str/camel nil)
;; =&gt; nil
</code></pre>
<h3><a href="#capital" id="capital"></a>capital</h3>
<p>Uppercases the first character of a string.</p>
<pre><code class="language-clojure">(str/capital "foo")
;; =&gt; "Foo"

(str/capital nil)
;; =&gt; nil
</code></pre>
<h3><a href="#chars" id="chars"></a>chars</h3>
<p>Returns a seq of char strings from string.</p>
<pre><code class="language-clojure">(str/chars "bar")
;; =&gt; ["b" "a" "r"]

(str/chars nil)
;; =&gt; nil
</code></pre>
<h3><a href="#clean" id="clean"></a>clean</h3>
<p>Trim and replace multiple spaces with a single space.</p>
<pre><code class="language-clojure">(str/clean "  a   b   ")
;; =&gt; "a b"

(str/clean nil)
;; =&gt; nil
</code></pre>
<h3><a href="#collapse-whitespace" id="collapse-whitespace"></a>collapse-whitespace</h3>
<p>Converts any adjacent whitespace characters to a single space.</p>
<pre><code class="language-clojure">(str/collapse-whitespace "a\n\nb")
;; =&gt; "a b"

(str/collapse-whitespace nil)
;; =&gt; nil
</code></pre>
<h3><a href="#css-selector" id="css-selector"></a>css-selector</h3>
<p>Convert a JavaScript style selector to CSS style selector</p>
<pre><code class="language-clojure">(str/css-selector "PrependedWithDash")
;; =&gt; "-prepended-with-dash"

(str/css-selector "noPrependedWithDash")
;; =&gt; "no-prepended-with-dash"

(str/css-selector nil)
;; =&gt; nil
</code></pre>
<h3><a href="#digits" id="digits"></a>digits?</h3>
<p>Checks if a string contains only digits.</p>
<pre><code class="language-clojure">(str/digits? nil)
;; =&gt; false

(str/digits? "1.1")
;; =&gt; false

(str/digits? "210")
;; =&gt; true
</code></pre>
<h3><a href="#empty" id="empty"></a>empty?</h3>
<p>Check if the string is empty.</p>
<pre><code class="language-clojure">(str/empty? "foobar")
;; =&gt; false

(str/empty? "")
;; =&gt; true

(str/empty? " ")
;; =&gt; false

(str/empty? nil)
;; =&gt; false
</code></pre>
<h3><a href="#empty-or-nil" id="empty-or-nil"></a>empty-or-nil?</h3>
<p>Check if the string is empty or is nil.</p>
<pre><code class="language-clojure">(str/empty-or-nil? "foobar")
;; =&gt; false

(str/empty-or-nil? nil)
;; =&gt; true

(str/empty? "")
;; =&gt; true

(str/empty? " ")
;; =&gt; false
</code></pre>
<h3><a href="#ends-with" id="ends-with"></a>ends-with?</h3>
<p>Check if the string ends with suffix.</p>
<pre><code class="language-clojure">(str/ends-with? "foobar" "bar")
;; =&gt; true

(str/ends-with? "foobar" nil)
;; =&gt; false

(str/ends-with? nil "bar")
;; =&gt; false
</code></pre>
<h3><a href="#format" id="format"></a>format</h3>
<p>Simple string formatting function.</p>
<p>The string formating works in two main modes: indexed and associative.</p>
<p>The indexed mode is the most simple and consists in using <code>%s</code> tokens in the string indicating the position where interpolation should be done and an arbitrary number of non associate arguments. Format will replace all <code>%s</code> occurrences with the provided values in ordered mode:</p>
<pre><code class="language-clojure">(str/format "hello %s and %s" "yen" "ciri")
;; =&gt; "hello yen and ciri"
</code></pre>
<p>If you don’t provide enough values, the <code>%s</code> tokens won’t be changed:</p>
<pre><code class="language-clojure">(str/format "hello %s and %s" "yen")
;; "hello yen and %s"
</code></pre>
<p>There are also the associative mode that consists in passing only one associative argument (map or vector) and use named interpolation tokens:</p>
<pre><code class="language-clojure">(str/format "hello %(name)s" {:name "yen"})
;; =&gt; "hello yen"
</code></pre>
<p>A part of the <code>%()s</code> syntax, the <code>$something</code> can be used:</p>
<pre><code class="language-clojure">(str/format "hello $name" {:name "yen"})
;; =&gt; "hello yen"
</code></pre>
<p>And you can access to indexed positions of an vector using <code>$0</code>, <code>$1</code>, <code>$N</code> syntax:</p>
<pre><code class="language-clojure">(str/format "hello $0" ["yen"])
;; =&gt; "hello yen"
</code></pre>
<p>You can use <code>str/fmt</code> as shorter alias to <code>str/format</code> function.  This performs the formatting at runtime, so consider using the <code>istr</code> or <code>ffmt</code> macros if you can, because they will have much lower overhead.</p>
<h3><a href="#human" id="human"></a>human</h3>
<p>Convert a string or keyword to a human friendly string (lower case and spaces).</p>
<pre><code class="language-clojure">(str/human "JustNiceForReading")
;; =&gt; "just nice for reading"

(str/human :great-for-csv-headers)
;; =&gt; "great for csv headers"

(str/human nil)
;; =&gt; nil
</code></pre>
<h3><a href="#includes" id="includes"></a>includes?</h3>
<p>Determines whether a string includes a substring.</p>
<pre><code class="language-clojure">(str/includes? "foobar" "bar")
;; =&gt; true

(str/includes? "foobar" nil)
;; =&gt; false

(str/includes? nil nil)
;; =&gt; false
</code></pre>
<h3><a href="#join" id="join"></a>join</h3>
<p>Join strings together with given separator.</p>
<pre><code class="language-clojure">(str/join ["foo" "bar"])
;; =&gt; "foobar"

(str/join "," ["foo" "bar"])
;; =&gt; "foo,bar"
</code></pre>
<h3><a href="#js-selector" id="js-selector"></a>js-selector</h3>
<p>Convert a CSS style selector to JavaScript style selector.</p>
<pre><code class="language-clojure">(str/js-selector "-pascal-case-me")
;; =&gt; "PascalCaseMe"

(str/js-selector "camel-case-me")
;; =&gt; "camelCaseMe"

(str/js-selector nil)
;; =&gt; nil
</code></pre>
<h3><a href="#kebab" id="kebab"></a>kebab</h3>
<p>Convert a string or keyword into a kebab-cased-string.</p>
<pre><code class="language-clojure">(str/kebab "Favorite BBQ food")
;; =&gt; "favorite-bbq-food"

(str/kebab :favorite-bbq-food)
;; =&gt; "favorite-bbq-food"

(str/kebab nil)
;; =&gt; nil
</code></pre>
<h3><a href="#keyword" id="keyword"></a>keyword</h3>
<p>A more helpful and forgiving version of <code>clojure.core/keyword</code>.</p>
<pre><code class="language-clojure">(str/keyword "just_doIt Right")
;; =&gt; :just-do-it-right

(str/keyword "foo" "auto namespace me")
;; =&gt; :foo/auto-namespace-me

;; and assuming the user namespace
(str/keyword *ns* "auto namespace me")
;; =&gt; :user/auto-namespace-me

(str/keyword nil)
;; =&gt; nil
</code></pre>
<h3><a href="#letters" id="letters"></a>letters?</h3>
<p>This is an unicode aware version of <code>alpha?</code>.</p>
<pre><code class="language-clojure">(str/letters? nil)
;; =&gt; false

(str/letters? " ")
;; =&gt; false

(str/letters? "Test")
;; =&gt; true

(str/letters? "Русский")
;; =&gt; true
</code></pre>
<h3><a href="#lines" id="lines"></a>lines</h3>
<p>Return a list of the lines in the string.</p>
<pre><code class="language-clojure">(str/lines "foo\nbar")
;; =&gt; ["foo" "bar"]

(str/lines nil)
;; =&gt; nil
</code></pre>
<h3><a href="#lower" id="lower"></a>lower</h3>
<p>Convert a string to all lower-case in a locale independent manner:</p>
<pre><code class="language-clojure">(str/lower "FOO")
;; =&gt; "foo"

(str/lower nil)
;; =&gt; nil
</code></pre>
<p>For locale awareness, use <code>locale-lower</code> alternative function.</p>
<h3><a href="#ltrim" id="ltrim"></a>ltrim</h3>
<p>Removes whitespace or specified characters from left side of string.</p>
<pre><code class="language-clojure">(str/ltrim " foo ")
;; =&gt; "foo "

(str/ltrim "-foo-", "-")
;; =&gt; "foo-"

(str/ltrim nil)
;; =&gt; nil
</code></pre>
<h3><a href="#numeric" id="numeric"></a>numeric?</h3>
<p>Checks if a string contains only numeric characters.</p>
<pre><code class="language-clojure">(str/numeric? nil)
;; =&gt; false

(str/numeric? "1.1")
;; =&gt; true

(str/numeric? "2e10")
;; =&gt; true
</code></pre>
<h3><a href="#pad" id="pad"></a>pad</h3>
<p>Pads the string with characters until the total string length is equal to the passed length parameter.</p>
<p>By default, pads on the left with the space char.</p>
<pre><code class="language-clojure">(str/pad "1" {:length 8})
;; =&gt; "       1"

(str/pad nil {:length 8})
;; =&gt; nil

(str/pad "1" {:length 8 :padding "0"})
;; =&gt; "00000001"

(str/pad "1" {:length 8 :padding "0" :type :right})
;; =&gt; "10000000"

(str/pad "1" {:length 8 :padding "0" :type :both})
;; =&gt; "00001000"
</code></pre>
<h3><a href="#pascal" id="pascal"></a>pascal</h3>
<p>Convert a string or keyword into a PascalCasedString (aka, UpperCamelCase and ClassCase).</p>
<pre><code class="language-clojure">(str/pascal "my name is epeli")
;; =&gt; "MyNameIsEpeli"

(str/pascal :some-record)
;; =&gt; "SomeRecord"

(str/pascal nil)
;; =&gt; nil
</code></pre>
<h3><a href="#phrase" id="phrase"></a>phrase</h3>
<p>Convert a potentially mixed string or keyword into a capitalized, spaced string</p>
<pre><code class="language-clojure">(str/phrase "  capitalize dash-CamelCase_underscore trim  ")
;; =&gt; "Capitalize dash camel case underscore trim"

(str/phrase :nobody-uses-keywords-this-long-but-it-still-works)
;; =&gt; "Nobody uses keywords this long but it still works"

(str/phrase nil)
;; =&gt; nil
</code></pre>
<h3><a href="#prune" id="prune"></a>prune</h3>
<p>Truncates a string to certain width and adds “…” if necessary. Making sure that the pruned string does not exceed the original length and avoid half-chopped words when truncating.</p>
<pre><code class="language-clojure">(str/prune "Hello World" 5)
;; =&gt; "Hello..."

(str/prune "Hello World" 8)
;; =&gt; "Hello..."

(str/prune "Hello World" 11 " (...)")
;; =&gt; "Hello (...)"

(str/prune nil 5)
;; =&gt; nil
</code></pre>
<h3><a href="#quote" id="quote"></a>quote</h3>
<p>Quote a string.</p>
<pre><code class="language-clojure">(str/quote "a")
;; =&gt; "\"a\""

(str/quote nil)
;; =&gt; nil
</code></pre>
<h3><a href="#repeat" id="repeat"></a>repeat</h3>
<p>Repeats string N times.</p>
<pre><code class="language-clojure">(str/repeat "a" 3)
;; =&gt; "aaa"

(str/repeat nil 3)
;; =&gt; nil
</code></pre>
<h3><a href="#replace" id="replace"></a>replace</h3>
<p>Replaces all instances of match with replacement in s.</p>
<pre><code class="language-clojure">(str/replace "aa bb aa" "aa" "kk")
;; =&gt; "kk bb kk"

(str/replace "aa bb aa" #"aa" "kk")
;; =&gt; "kk bb kk"

(str/replace nil #"aa" "kk")
;; =&gt; nil
</code></pre>
<h3><a href="#replace-first" id="replace-first"></a>replace-first</h3>
<p>Replaces first instance of match with replacement in s.</p>
<pre><code class="language-clojure">(str/replace-first "aa bb aa" "aa" "kk")
;; =&gt; "kk bb aa"

(str/replace-first "aa bb aa" #"aa" "kk")
;; =&gt; "kk bb aa"

(str/replace-first nil #"aa" "kk")
;; =&gt; nil
</code></pre>
<h3><a href="#reverse" id="reverse"></a>reverse</h3>
<p>Return string reverted</p>
<pre><code class="language-clojure">(str/reverse "bar")
;; =&gt; "rab"

(str/reverse nil)
;; =&gt; nil
</code></pre>
<h3><a href="#rtrim" id="rtrim"></a>rtrim</h3>
<p>Removes whitespace or specified characters from right side of string.</p>
<pre><code class="language-clojure">(str/rtrim " foo ")
;; =&gt; " foo"

(str/rtrim "-foo-", "-")
;; =&gt; "-foo"

(str/rtrim nil)
;; =&gt; nil
</code></pre>
<h3><a href="#slice" id="slice"></a>slice</h3>
<p>Extracts a section of a string and returns a new string.</p>
<pre><code class="language-clojure">(str/slice "123" 1)
;; =&gt; "23"

(str/slice "1234" 1 3)
;; =&gt; "23"

(str/slice nil 1 3)
;; =&gt; nil
</code></pre>
<h3><a href="#slug" id="slug"></a>slug</h3>
<p>Transforms string or keyword into URL slug.</p>
<pre><code class="language-clojure">(str/slug "Un �l�phant � l'or�e du bois")
;; =&gt; "un-elephant-a-loree-du-bois"

(str/slug nil)
;; =&gt; nil
</code></pre>
<p>Traditionally, slug is consisted in ascii characters, but in modern ages, the URL and domain names already supports unicode characters. The <code>uslug</code> is more modern version of slug function that respects the unicode characters.</p>
<h3><a href="#snake" id="snake"></a>snake</h3>
<p>Convert a string or keyword to a snake_cased_string.</p>
<pre><code class="language-clojure">(str/snake "Slither-sliter Slither")
;; =&gt; "slither_slither_slither"

(str/snake :slither-slither)
;; =&gt; "slither_slither"

(str/snake nil)
;; =&gt; nil
</code></pre>
<h3><a href="#split" id="split"></a>split</h3>
<p>Splits a string on a separator a limited number of times. The separator can be a string or RegExp instance.</p>
<pre><code class="language-clojure">(str/split "1 2 3")
;; =&gt; ["1" "2" "3"]

(str/split "1 2 3" " ")
;; =&gt; ["1" "2" "3"])

(str/split "1 2 3" #"\s")
;; =&gt; ["1" "2" "3"]

(str/split "1 2 3" #"\s" 2)
;; =&gt; ["1" "2 3"]

(str/split nil)
;; =&gt; nil
</code></pre>
<h3><a href="#starts-with" id="starts-with"></a>starts-with?</h3>
<p>Check if the string starts with prefix.</p>
<pre><code class="language-clojure">(str/starts-with? "foobar" "foo")
;; =&gt; true

(str/starts-with? "foobar" nil)
;; =&gt; false

(str/starts-with? nil "foo")
;; =&gt; false
</code></pre>
<h3><a href="#index-of" id="index-of"></a>index-of</h3>
<p>Return index of value (string or char) in s, optionally searching forward from from-index. Return nil if value not found.</p>
<pre><code class="language-clojure">(str/index-of "foobar" "foo")
;; =&gt; 0

(str/index-of "foobar" nil)
;; =&gt; nil
</code></pre>
<h3><a href="#last-index-of" id="last-index-of"></a>last-index-of</h3>
<p>Return last index of value (string or char) in s, optionally searching backward from from-index. Return nil if value not found.</p>
<pre><code class="language-clojure">(str/last-index-of "foobar" "foo")
;; =&gt; 0

(str/last-index-of "foobar" nil)
;; =&gt; nil
</code></pre>
<h3><a href="#strip-newlines" id="strip-newlines"></a>strip-newlines</h3>
<p>Takes a string and replaces newlines with a space. Multiple lines are replaced with a single space.</p>
<pre><code class="language-clojure">(str/strip-newlines "a\n\nb")
;; =&gt; "a b"

(str/strip-newlines nil)
;; =&gt; nil
</code></pre>
<h3><a href="#strip-prefix" id="strip-prefix"></a>strip-prefix</h3>
<p>Remove prefix from string if it matches exactly or leave the string untouched.</p>
<pre><code class="language-clojure">(str/strip-prefix nil nil)
;; =&gt; nil

(str/strip-prefix "a" nil)
;; =&gt; "a"

(str/strip-prefix "-=a" "-=")
;; =&gt; "a"
</code></pre>
<h3><a href="#strip-suffix" id="strip-suffix"></a>strip-suffix</h3>
<p>Remove suffix from string if it matches exactly or leave the string untouched.</p>
<pre><code class="language-clojure">(str/strip-suffix nil nil)
;; =&gt; nil

(str/strip-suffix "a" nil)
;; =&gt; "a"

(str/strip-suffix "a=-" "=-")
;; =&gt; "a"
</code></pre>
<h3><a href="#strip-tags" id="strip-tags"></a>strip-tags</h3>
<p>Remove html tags from string.</p>
<pre><code class="language-clojure">(str/strip-tags "&lt;p&gt;just &lt;b&gt;some&lt;/b&gt; text&lt;/p&gt;")
;; =&gt; "just some text"

(str/strip-tags "&lt;p&gt;just &lt;b&gt;some&lt;/b&gt; text&lt;/p&gt;" ["p"])
;; =&gt; "just &lt;b&gt;some&lt;/b&gt; text"

(str/strip-tags nil)
;; =&gt; nil
</code></pre>
<p>It also allows arbitrary replacements:</p>
<pre><code class="language-clojure">(str/strip-tags "&lt;p&gt;just&lt;br&gt;text&lt;/p&gt;" {:br "\n"})
;; =&gt; "just\ntext"

(str/strip-tags "&lt;p&gt;just&lt;br&gt;text&lt;/p&gt;" ["br"] {:br "\n"})
;; =&gt; "&lt;p&gt;just\ntext&lt;/p&gt;"
</code></pre>
<h3><a href="#surround" id="surround"></a>surround</h3>
<p>Surround a string with another string.</p>
<pre><code class="language-clojure">(str/surround "a" "-")
;; =&gt; "-a-"

(str/surround "a" "-^-")
;; =&gt; "-^-a-^-"

(str/surround nil "-^-")
;; =&gt; nil
</code></pre>
<h3><a href="#title" id="title"></a>title</h3>
<p>Convert a string or keyword into a space separated string with each word capitalized.</p>
<pre><code class="language-clojure">(str/title "a tale of two cities")
;; =&gt; "A Tale Of Two Cities"

(str/title :title-case)
;; =&gt; "Title Case"

(str/title nil)
;; =&gt; nil
</code></pre>
<h3><a href="#to-bool" id="to-bool"></a>to-bool</h3>
<p>Returns true for 1/on/true/yes string values (case-insensitive), false otherwise.</p>
<pre><code class="language-clojure">(str/to-bool "hello")
;; =&gt; false

(str/to-bool "on")
;; =&gt; true
</code></pre>
<h3><a href="#trim" id="trim"></a>trim</h3>
<p>Removes whitespace or specified characters from both ends of string.</p>
<pre><code class="language-clojure">(str/trim " foo ")
;; =&gt; "foo"

(str/trim "-foo-", "-")
;; =&gt; "foo"

(str/trim nil)
;; =&gt; nil
</code></pre>
<h3><a href="#unlines" id="unlines"></a>unlines</h3>
<p>Joins a list of strings with a newline separator.  This operation is the opposite of lines.</p>
<pre><code class="language-clojure">(str/unlines ["foo" "nbar"])
;; =&gt; "foo\nbar"

(str/unlines nil)
;; =&gt; nil
</code></pre>
<h3><a href="#unquote" id="unquote"></a>unquote</h3>
<p>Unquote a string.</p>
<pre><code class="language-clojure">(str/unquote "\"a\"")
;; =&gt; "a"

(str/unquote nil)
;; =&gt; nil
</code></pre>
<h3><a href="#unsurround" id="unsurround"></a>unsurround</h3>
<p>Unsurround a string surrounded by another.</p>
<pre><code class="language-clojure">(str/unsurround "-a-" "-")
;; =&gt; "a"

(str/unsurround "-^-a-^-" "-^-")
;; =&gt; "a"

(str/unsurround nil "-")
;; =&gt; nil
</code></pre>
<h3><a href="#upper" id="upper"></a>upper</h3>
<p>Convert a string to all upper-case in a locale independent manner:</p>
<pre><code class="language-clojure">(str/upper "foobar")
;; =&gt; "FOOBAR"

(str/upper nil)
;; =&gt; nil
</code></pre>
<p>For locale awareness, use <code>locale-upper</code> alternative function.</p>
<h3><a href="#word" id="word"></a>word?</h3>
<p>This is a unicode aware version of <code>alnum?</code>.</p>
<pre><code class="language-clojure">(str/word? nil)
;; =&gt; false

(str/word? "")
;; =&gt; false

(str/word? "Русский222")
;; =&gt; true
</code></pre>
<h3><a href="#words" id="words"></a>words</h3>
<p>Returns a vector of the words in the string. Can be provided with a regular expression that matches a single word (defaults to <code>[a-zA-Z0-9_-]+</code>).</p>
<pre><code>(str/words nil)
;; =&gt; nil

(str/words "foo, bar")
;; =&gt; ["foo" "bar"]

(str/words "foo, bar." #"[^, ]+")
;; =&gt; ["foo" "bar."]
</code></pre>
<h2><a href="#run-tests" id="run-tests"></a>Run tests</h2>
<p><em>cuerdas</em> has targeted some parts of implementation for Clojure and ClojureScript using Reader Conditionals.</p>
<p>Run tests in the Clojure environment:</p>
<pre><code>$ clojure -M:dev:test
</code></pre>
<p>Run tests in the ClojureScript environment:</p>
<pre><code>$ clojure -M:dev ./tools.clj test &lt;once|watch&gt;
</code></pre>
<h2><a href="#how-to-contribute" id="how-to-contribute"></a>How to Contribute?</h2>
<p><strong>cuerdas</strong>’ source is on <a href="https://github.com/funcool/cuerdas">https://github.com/funcool/cuerdas</a><a href="github">github</a>.</p>
<p>Unlike Clojure and other Clojure contrib libs, cuerdas does not have many restrictions for contributions.</p>
<p><em>Pull requests are welcome!</em></p>
<h2><a href="#license" id="license"></a>License</h2>
<p><em>cuerdas</em> is licensed under BSD (2-Clause) license:</p>
<pre><code>Copyright (c) 2015-Now Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</code></pre>
</div></div></div></body></html>